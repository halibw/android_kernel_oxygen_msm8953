--- drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c
+++ drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -14,9 +14,8 @@
 #include <asm/div64.h>
 #include "msm_isp_util.h"
 #include "msm_isp_axi_util.h"
-#include "trace/events/msm_cam.h"
-
 
+#define HANDLE_TO_IDX(handle) (handle & 0xFF)
 #define ISP_SOF_DEBUG_COUNT 0
 static int msm_isp_update_dual_HW_ms_info_at_start(
 	struct vfe_device *vfe_dev,
@@ -183,10 +182,6 @@ int msm_isp_validate_axi_request(struct msm_vfe_axi_shared_data *axi_data,
 	case V4L2_PIX_FMT_P16GBRG10:
 	case V4L2_PIX_FMT_P16GRBG10:
 	case V4L2_PIX_FMT_P16RGGB10:
-	case V4L2_PIX_FMT_P16BGGR12:
-	case V4L2_PIX_FMT_P16GBRG12:
-	case V4L2_PIX_FMT_P16GRBG12:
-	case V4L2_PIX_FMT_P16RGGB12:
 	case V4L2_PIX_FMT_JPEG:
 	case V4L2_PIX_FMT_META:
 	case V4L2_PIX_FMT_META10:
@@ -253,9 +248,6 @@ int msm_isp_validate_axi_request(struct msm_vfe_axi_shared_data *axi_data,
 	stream_info->runtime_output_format = stream_info->output_format;
 	stream_info->stream_src = stream_cfg_cmd->stream_src;
 	stream_info->frame_based = stream_cfg_cmd->frame_base;
-	axi_data->src_info[SRC_TO_INTF(stream_info->stream_src)].session_id =
-		stream_cfg_cmd->session_id;
-
 	return 0;
 }
 
@@ -330,10 +322,6 @@ static uint32_t msm_isp_axi_get_plane_size(
 	case V4L2_PIX_FMT_P16GBRG10:
 	case V4L2_PIX_FMT_P16GRBG10:
 	case V4L2_PIX_FMT_P16RGGB10:
-	case V4L2_PIX_FMT_P16BGGR12:
-	case V4L2_PIX_FMT_P16GBRG12:
-	case V4L2_PIX_FMT_P16GRBG12:
-	case V4L2_PIX_FMT_P16RGGB12:
 		size = plane_cfg[plane_idx].output_height *
 		plane_cfg[plane_idx].output_width;
 		break;
@@ -607,7 +595,6 @@ static int msm_isp_check_epoch_status(struct vfe_device **vfe_dev,
 				vfe_dev_cur->pdev->id,
 				vfe_dev_cur->common_data->dual_vfe_res->
 					epoch_sync_mask);
-			msm_isp_dump_ping_pong_mismatch();
 			goto fatal;
 		}
 
@@ -686,7 +673,7 @@ void msm_isp_update_framedrop_reg(struct vfe_device *vfe_dev,
 					MSM_VFE_STREAM_STOP_PERIOD;
 		}
 
-		if (stream_info->undelivered_request_cnt == 1)
+		if (stream_info->undelivered_request_cnt > 0)
 			stream_info->current_framedrop_period =
 				MSM_VFE_STREAM_STOP_PERIOD;
 
@@ -736,9 +723,8 @@ void msm_isp_reset_framedrop(struct vfe_device *vfe_dev,
 		stream_info->runtime_num_burst_capture);
 }
 
-static void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
-	struct msm_isp_timestamp *ts, struct msm_isp_sof_info *sof_info,
-	enum msm_vfe_input_src frame_src)
+void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
+	struct msm_isp_timestamp *ts, struct msm_isp_sof_info *sof_info)
 {
 	struct msm_vfe_axi_stream *stream_info;
 	struct msm_vfe_axi_shared_data *axi_data;
@@ -762,12 +748,10 @@ static void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
 		sof_info->regs_not_updated =
 			vfe_dev->reg_update_requested;
 	}
-
 	for (i = 0; i < VFE_AXI_SRC_MAX; i++) {
 		struct msm_vfe_axi_stream *temp_stream_info;
+
 		stream_info = &axi_data->stream_info[i];
-		if (SRC_TO_INTF(stream_info->stream_src) != frame_src)
-			continue;
 		stream_idx = HANDLE_TO_IDX(stream_info->stream_handle);
 
 		/*
@@ -805,20 +789,23 @@ static void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
 			sof_info->axi_updating_mask |=
 				1 << stream_idx;
 		}
-		/* report frame drop per stream */
-		i = stream_info->bufq_handle[VFE_BUF_QUEUE_DEFAULT] &
-				0xFF;
-		if (vfe_dev->error_info.stream_framedrop_count[i]) {
-			ISP_DBG("%s: get buf failed i %d\n", __func__,
-				i);
-			sof_info->stream_get_buf_fail_mask |= (1 << i);
-			vfe_dev->error_info.
-				stream_framedrop_count[i] = 0;
-		}
 	}
 
 	vfe_dev->reg_updated = 0;
 
+	/* report frame drop per stream */
+	if (vfe_dev->error_info.framedrop_flag) {
+		for (i = 0; i < BUF_MGR_NUM_BUF_Q; i++) {
+			if (vfe_dev->error_info.stream_framedrop_count[i]) {
+				ISP_DBG("%s: get buf failed i %d\n", __func__,
+					i);
+				sof_info->stream_get_buf_fail_mask |= (1 << i);
+				vfe_dev->error_info.
+					stream_framedrop_count[i] = 0;
+			}
+		}
+		vfe_dev->error_info.framedrop_flag = 0;
+	}
 }
 
 void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
@@ -829,8 +816,8 @@ void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
 	enum msm_vfe_dual_hw_type dual_hw_type;
 	enum msm_vfe_dual_hw_ms_type ms_type;
 	struct msm_vfe_sof_info *master_sof_info = NULL;
-	int32_t time, master_time, delta, i;
-	uint32_t sof_incr = 0, temp_frame_id;
+	int32_t time, master_time, delta;
+	uint32_t sof_incr = 0;
 	uint32_t master_last_slave_diff = 0;
 	uint32_t last_curr_diff = 0;
 	unsigned long flags;
@@ -841,32 +828,9 @@ void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
 			ts);
 	dual_hw_type =
 		vfe_dev->axi_data.src_info[frame_src].dual_hw_type;
-	ms_type = vfe_dev->axi_data.src_info[frame_src].
-			dual_hw_ms_info.dual_hw_ms_type;
-	src_info = vfe_dev->axi_data.src_info;
-
-	if (src_info[frame_src].frame_id == 0) {
-		for (i = VFE_PIX_0; i < VFE_SRC_MAX; i++) {
-			if (i == frame_src)
-				continue;
-
-			if (src_info[frame_src].session_id !=
-				src_info[i].session_id)
-				continue;
-
-			if (src_info[i].active == 0)
-				continue;
-
-			if (i == VFE_PIX_0)
-				temp_frame_id = src_info[i].frame_id - 1;
-			else
-				temp_frame_id = src_info[i].frame_id;
-
-			if (src_info[frame_src].frame_id < temp_frame_id)
-				src_info[frame_src].frame_id = temp_frame_id;
-		}
-	}
-
+	ms_type =
+		vfe_dev->axi_data.src_info[frame_src].
+		dual_hw_ms_info.dual_hw_ms_type;
 	/*
 	 * Increment frame_id if
 	 *   1. Not Master Slave
@@ -969,42 +933,12 @@ void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
 		flags);
 }
 
-static void msm_isp_update_pd_stats_idx(struct vfe_device *vfe_dev,
-	enum msm_vfe_input_src frame_src)
-{
-	struct msm_vfe_axi_stream *pd_stream_info = NULL;
-	uint32_t pingpong_status = 0, pingpong_bit = 0;
-	struct msm_isp_buffer *done_buf = NULL;
-
-	if (frame_src < VFE_RAW_0 || frame_src >  VFE_RAW_2)
-		return;
-
-	pd_stream_info = &(vfe_dev->common_data->dual_vfe_res->
-		axi_data[vfe_dev->pdev->id]->
-		stream_info[RDI_INTF_0 + frame_src - VFE_RAW_0]);
-
-	if (pd_stream_info && (pd_stream_info->state == ACTIVE) &&
-		(pd_stream_info->rdi_input_type ==
-		MSM_CAMERA_RDI_PDAF)) {
-		pingpong_status = vfe_dev->hw_info->vfe_ops.axi_ops.
-					get_pingpong_status(vfe_dev);
-		pingpong_bit = ((pingpong_status >>
-			pd_stream_info->wm[0]) & 0x1);
-		done_buf = pd_stream_info->buf[pingpong_bit];
-		if (done_buf)
-			vfe_dev->pd_buf_idx = done_buf->buf_idx;
-		else
-			vfe_dev->pd_buf_idx = 0xF;
-	}
-}
-
 void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
 	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts)
 {
 	struct msm_isp_event_data event_data;
 	struct msm_vfe_sof_info *sof_info = NULL, *self_sof = NULL;
 	enum msm_vfe_dual_hw_ms_type ms_type;
-	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	int i, j;
 	unsigned long flags;
 
@@ -1012,15 +946,6 @@ void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
 
 	switch (event_type) {
 	case ISP_EVENT_SOF:
-		for (i = 0; i < VFE_AXI_SRC_MAX; i++) {
-			if (SRC_TO_INTF(axi_data->stream_info[i].stream_src) ==
-				frame_src) {
-				/* update ping pong bit for controllable */
-				/* output */
-				axi_data->stream_info[i].sw_sof_ping_pong_bit =
-				      axi_data->stream_info[i].sw_ping_pong_bit;
-			}
-		}
 		if (frame_src == VFE_PIX_0) {
 			if (vfe_dev->isp_sof_debug < ISP_SOF_DEBUG_COUNT)
 				pr_err("%s: PIX0 frame id: %u\n", __func__,
@@ -1046,9 +971,6 @@ void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
 		ISP_DBG("%s: vfe %d frame_src %d frame id: %u\n", __func__,
 			vfe_dev->pdev->id, frame_src,
 			vfe_dev->axi_data.src_info[frame_src].frame_id);
-		trace_msm_cam_isp_bufcount("msm_isp_notify:",
-		vfe_dev->pdev->id,
-		vfe_dev->axi_data.src_info[frame_src].frame_id, frame_src);
 
 		/*
 		 * Cannot support dual_cam and framedrop same time in union.
@@ -1102,15 +1024,9 @@ void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
 		} else {
 			if (frame_src <= VFE_RAW_2) {
 				msm_isp_check_for_output_error(vfe_dev, ts,
-					&event_data.u.sof_info, frame_src);
+					&event_data.u.sof_info);
 			}
 		}
-		/*
-		 * Get and store the buf idx for PD stats
-		 * this is to send the PD stats buffer address
-		 * in BF stats done.
-		 */
-		msm_isp_update_pd_stats_idx(vfe_dev, frame_src);
 		break;
 
 	default:
@@ -1274,7 +1190,7 @@ int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
 		return -EINVAL;
 	}
 
-	stream_info->rdi_input_type = stream_cfg_cmd->rdi_input_type;
+	stream_info->memory_input = stream_cfg_cmd->memory_input;
 	vfe_dev->reg_update_requested &=
 		~(BIT(SRC_TO_INTF(stream_info->stream_src)));
 
@@ -1558,11 +1474,12 @@ void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev,
 {
 	int i, j;
 	uint32_t update_state;
-	unsigned long flags;
+	unsigned long flags, flags1;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	struct msm_vfe_axi_stream *stream_info;
 	int num_stream = 0;
 
+	spin_lock_irqsave(&vfe_dev->common_data->common_dev_data_lock, flags);
 	for (i = 0; i < VFE_AXI_SRC_MAX; i++) {
 		if (SRC_TO_INTF(axi_data->stream_info[i].stream_src) !=
 			frame_src) {
@@ -1576,7 +1493,7 @@ void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev,
 			!stream_info->controllable_output) ||
 			stream_info->state == AVAILABLE)
 			continue;
-		spin_lock_irqsave(&stream_info->lock, flags);
+		spin_lock_irqsave(&stream_info->lock, flags1);
 		if (stream_info->state == PAUSING) {
 			/*AXI Stopped, apply update*/
 			stream_info->state = PAUSED;
@@ -1590,8 +1507,10 @@ void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev,
 		} else if (stream_info->state == RESUMING) {
 			msm_isp_update_dual_HW_axi(vfe_dev, stream_info);
 		}
-		spin_unlock_irqrestore(&stream_info->lock, flags);
+		spin_unlock_irqrestore(&stream_info->lock, flags1);
 	}
+	spin_unlock_irqrestore(&vfe_dev->common_data->common_dev_data_lock,
+		flags);
 	if (num_stream)
 		update_state = atomic_dec_return(
 			&axi_data->axi_cfg_update[frame_src]);
@@ -1641,6 +1560,10 @@ void msm_isp_halt_send_error(struct vfe_device *vfe_dev, uint32_t event)
 		/* Recovery is already in Progress */
 		return;
 
+	/* if there are no active streams - do not start recovery */
+	if (!vfe_dev->axi_data.num_active_stream)
+		return;
+
 	if (ISP_EVENT_PING_PONG_MISMATCH == event &&
 		vfe_dev->axi_data.recovery_count < MAX_RECOVERY_THRESHOLD) {
 		vfe_dev->hw_info->vfe_ops.irq_ops.
@@ -1863,7 +1786,7 @@ static int msm_isp_cfg_ping_pong_address(struct vfe_device *vfe_dev,
 	uint32_t stream_idx = HANDLE_TO_IDX(stream_info->stream_handle);
 	uint32_t buffer_size_byte = 0;
 	int32_t word_per_line = 0;
-	dma_addr_t paddr;
+	dma_addr_t paddr = 0;
 	struct dual_vfe_resource *dual_vfe_res = NULL;
 	uint32_t vfe_id = 0;
 	unsigned long flags;
@@ -1932,7 +1855,9 @@ static int msm_isp_cfg_ping_pong_address(struct vfe_device *vfe_dev,
 
 		if (dual_vfe_res) {
 			for (vfe_id = 0; vfe_id < MAX_VFE; vfe_id++) {
-				if (vfe_id != vfe_dev->pdev->id)
+				bool lock = vfe_id != vfe_dev->pdev->id;
+
+				if (lock)
 					spin_lock_irqsave(
 						&vfe_dev->common_data->
 						common_dev_axi_lock, flags);
@@ -1962,7 +1887,7 @@ static int msm_isp_cfg_ping_pong_address(struct vfe_device *vfe_dev,
 						buf[!pingpong_bit] =
 						buf;
 				}
-				if (vfe_id != vfe_dev->pdev->id)
+				if (lock)
 					spin_unlock_irqrestore(
 						&vfe_dev->common_data->
 						common_dev_axi_lock, flags);
@@ -2098,10 +2023,6 @@ static int msm_isp_process_done_buf(struct vfe_device *vfe_dev,
 		}
 	}
 
-	trace_msm_cam_isp_bufcount("msm_isp_process_done_buf:",
-		vfe_dev->pdev->id, frame_id,
-		SRC_TO_INTF(stream_info->stream_src));
-
 	buf_event.frame_id = frame_id;
 	buf_event.timestamp = *time_stamp;
 	buf_event.u.buf_done.session_id = stream_info->session_id;
@@ -2306,10 +2227,8 @@ int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev,
 	struct msm_vfe_axi_stream *stream_info;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	uint64_t total_pix_bandwidth = 0, total_rdi_bandwidth = 0;
-	uint64_t total_fe_bandwidth = 0;
 	uint32_t num_pix_streams = 0;
 	uint64_t total_bandwidth = 0;
-	int bpp = 0;
 
 	for (i = 0; i < VFE_AXI_SRC_MAX; i++) {
 		stream_info = &axi_data->stream_info[i];
@@ -2333,16 +2252,7 @@ int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev,
 		}
 	}
 
-	if (axi_data->src_info[VFE_PIX_0].input_mux == EXTERNAL_READ
-		&& num_pix_streams){
-			bpp = msm_isp_get_bit_per_pixel(axi_data->
-			src_info[VFE_PIX_0].input_format);
-			total_fe_bandwidth =
-			(axi_data->src_info[VFE_PIX_0].pixel_clock / 8) * bpp;
-	}
-
-	total_bandwidth = total_pix_bandwidth + total_rdi_bandwidth +
-			total_fe_bandwidth;
+	total_bandwidth = total_pix_bandwidth + total_rdi_bandwidth;
 		rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
 			(total_bandwidth + vfe_dev->hw_info->min_ab),
 			(total_bandwidth + vfe_dev->hw_info->min_ib));
@@ -2484,7 +2394,6 @@ int msm_isp_axi_reset(struct vfe_device *vfe_dev,
 	int rc = 0, i, j;
 	struct msm_vfe_axi_stream *stream_info;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
-    struct msm_vfe_frame_request_queue *queue_req;
 	uint32_t bufq_handle = 0, bufq_id = 0;
 	struct msm_isp_timestamp timestamp;
 	unsigned long flags;
@@ -2516,16 +2425,7 @@ int msm_isp_axi_reset(struct vfe_device *vfe_dev,
 			j--;
 			continue;
 		}
-        stream_info->undelivered_request_cnt = 0;
-		while (!list_empty(&stream_info->request_q)) {
-			queue_req = list_first_entry_or_null(
-				&stream_info->request_q,
-				struct msm_vfe_frame_request_queue, list);
-			if (queue_req) {
-				queue_req->cmd_used = 0;
-				list_del(&queue_req->list);
-			}
-		}
+
 		for (bufq_id = 0; bufq_id < VFE_BUF_QUEUE_MAX; bufq_id++) {
 			bufq_handle = stream_info->bufq_handle[bufq_id];
 			if (!bufq_handle)
@@ -2547,14 +2447,9 @@ int msm_isp_axi_reset(struct vfe_device *vfe_dev,
 					ISP_EVENT_BUF_FATAL_ERROR);
 				return rc;
 			}
-			/* Donot update frame_id for FE */
-			if (!(SRC_TO_INTF(stream_info->stream_src)
-				== VFE_PIX_0 &&
-				axi_data->src_info[VFE_PIX_0].input_mux
-				== EXTERNAL_READ))
-				axi_data->src_info[SRC_TO_INTF(stream_info->
-				stream_src)].frame_id = reset_cmd->frame_id;
 
+			axi_data->src_info[SRC_TO_INTF(stream_info->
+				stream_src)].frame_id = reset_cmd->frame_id;
 			msm_isp_reset_burst_count_and_frame_drop(vfe_dev,
 				stream_info);
 		}
@@ -3084,13 +2979,7 @@ static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev,
 				intf < VFE_SRC_MAX) {
 				vfe_dev->axi_data.src_info[intf].active = 0;
 				vfe_dev->axi_data.src_info[intf].flag = 0;
-				/* reset frame_id for RDI path */
-				if (halt) {
-					vfe_dev->
-					axi_data.src_info[intf].frame_id = 0;
-					vfe_dev->
-					axi_data.src_info[intf].eof_id = 0;
-				}
+
 			}
 		} else
 			src_mask |= (1 << intf);
@@ -3136,13 +3025,6 @@ static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev,
 			if (src_mask & (1 << i)) {
 				vfe_dev->axi_data.src_info[i].active = 0;
 				vfe_dev->axi_data.src_info[i].flag = 0;
-				/* reset frame_id for RDI path */
-				if (halt) {
-					vfe_dev->
-					axi_data.src_info[i].frame_id = 0;
-					vfe_dev->
-					axi_data.src_info[i].eof_id = 0;
-				}
 			}
 		}
 	}
@@ -3358,16 +3240,23 @@ static int msm_isp_request_frame(struct vfe_device *vfe_dev,
 	}
 
 	frame_src = SRC_TO_INTF(stream_info->stream_src);
-	trace_msm_cam_isp_bufcount("msm_isp_request_frame:",
-		vfe_dev->pdev->id, frame_id, frame_src);
-
+	pingpong_status =
+		vfe_dev->hw_info->vfe_ops.axi_ops.get_pingpong_status(
+			vfe_dev);
+	/*
+	 * If PIX stream is active then RDI path uses SOF frame ID of PIX
+	 * In case of standalone RDI streaming, SOF are used from
+	 * individual intf.
+	 */
 	/*
 	 * If frame_id = 1 then no eof check is needed
 	 */
-	if (((frame_src == VFE_PIX_0) && ((frame_id !=
+	if (((vfe_dev->axi_data.src_info[VFE_PIX_0].active) && ((frame_id !=
 		vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id + vfe_dev->
-		axi_data.src_info[VFE_PIX_0].sof_counter_step))) ||
-		((frame_src != VFE_PIX_0) && (frame_id !=
+		axi_data.src_info[VFE_PIX_0].sof_counter_step) ||
+		(frame_id <= vfe_dev->
+		axi_data.src_info[VFE_PIX_0].eof_id + 1))) ||
+		((!vfe_dev->axi_data.src_info[VFE_PIX_0].active) && (frame_id !=
 		vfe_dev->axi_data.src_info[frame_src].frame_id + vfe_dev->
 		axi_data.src_info[frame_src].sof_counter_step)) ||
 		stream_info->undelivered_request_cnt >= MAX_BUFFERS_IN_HW) {
@@ -3475,12 +3364,7 @@ static int msm_isp_request_frame(struct vfe_device *vfe_dev,
 			dual_vfe_res->wm_reload_mask[vfe_id] = 0;
 		}
 		stream_info->sw_ping_pong_bit = 0;
-		stream_info->sw_sof_ping_pong_bit = 0;
 	} else if (stream_info->undelivered_request_cnt == 2) {
-		if (stream_info->sw_sof_ping_pong_bit)
-			pingpong_status = VFE_PING_FLAG;
-		else
-			pingpong_status = VFE_PONG_FLAG;
 		rc = msm_isp_cfg_ping_pong_address(vfe_dev,
 				stream_info, pingpong_status, 0);
 		if (rc) {
@@ -3888,7 +3772,6 @@ void msm_isp_process_axi_irq_stream(struct vfe_device *vfe_dev,
 			spin_unlock_irqrestore(&stream_info->lock, flags);
 			pr_err("%s: Write master ping pong mismatch. Status: 0x%x\n",
 				__func__, pingpong_status);
-			msm_isp_dump_ping_pong_mismatch();
 			msm_isp_halt_send_error(vfe_dev,
 					ISP_EVENT_PING_PONG_MISMATCH);
 			return;
@@ -3966,6 +3849,7 @@ void msm_isp_process_axi_irq_stream(struct vfe_device *vfe_dev,
 			vfe_dev->error_info.stream_framedrop_count[
 				stream_info->bufq_handle[
 				VFE_BUF_QUEUE_DEFAULT] & 0xFF]++;
+			vfe_dev->error_info.framedrop_flag = 1;
 		}
 		spin_unlock_irqrestore(&stream_info->lock, flags);
 		return;
