--- drivers/media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c
+++ drivers/media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c
@@ -15,7 +15,6 @@
 
 #include <linux/module.h>
 #include <linux/pwm.h>
-#include <linux/delay.h>
 #include "msm_ir_led.h"
 #include "msm_camera_dt_util.h"
 
@@ -42,6 +41,7 @@ static int32_t msm_ir_led_get_subdev_id(
 {
 	uint32_t *subdev_id = (uint32_t *)arg;
 
+	CDBG("Enter\n");
 	if (!subdev_id) {
 		pr_err("subdevice ID is not valid\n");
 		return -EINVAL;
@@ -54,6 +54,7 @@ static int32_t msm_ir_led_get_subdev_id(
 	*subdev_id = ir_led_ctrl->pdev->id;
 
 	CDBG("subdev_id %d\n", *subdev_id);
+	CDBG("Exit\n");
 	return 0;
 }
 
@@ -63,64 +64,45 @@ static int32_t msm_ir_led_init(
 {
 	int32_t rc = 0;
 
+	CDBG("Enter\n");
+
 	rc = ir_led_ctrl->func_tbl->camera_ir_led_off(ir_led_ctrl, ir_led_data);
 
+	CDBG("Exit\n");
 	return rc;
 }
 
 static int32_t msm_ir_led_release(
-	struct msm_ir_led_ctrl_t *ir_led_ctrl,
-		struct msm_ir_led_cfg_data_t *ir_led_data)
+	struct msm_ir_led_ctrl_t *ir_led_ctrl)
 {
-	int32_t rc = -EFAULT;
+	int32_t rc = 0;
 
 	if (ir_led_ctrl->ir_led_state == MSM_CAMERA_IR_LED_RELEASE) {
 		pr_err("Invalid ir_led state = %d\n",
 			ir_led_ctrl->ir_led_state);
-		return rc;
+		return 0;
 	}
 
-	rc = ir_led_ctrl->func_tbl->camera_ir_led_off(ir_led_ctrl, ir_led_data);
+	rc = ir_led_ctrl->func_tbl->camera_ir_led_off(ir_led_ctrl, NULL);
 	if (rc < 0) {
 		pr_err("camera_ir_led_off failed (%d)\n", rc);
 		return rc;
 	}
 	ir_led_ctrl->ir_led_state = MSM_CAMERA_IR_LED_RELEASE;
-
-	return rc;
+	return 0;
 }
 
 static int32_t msm_ir_led_off(struct msm_ir_led_ctrl_t *ir_led_ctrl,
 	struct msm_ir_led_cfg_data_t *ir_led_data)
 {
-	int32_t rc = 0;
-
-	CDBG("pwm duty on(ns) %d, pwm period(ns) %d\n",
-		ir_led_data->pwm_duty_on_ns, ir_led_data->pwm_period_ns);
-
-	if (ir_led_data->pwm_period_ns <= 0)
-		ir_led_data->pwm_period_ns = DEFAULT_PWM_TIME_PERIOD_NS;
-
-	if (ir_led_data->pwm_duty_on_ns != 0)
-		ir_led_data->pwm_duty_on_ns = DEFAULT_PWM_DUTY_CYCLE_NS;
-
-	if (ir_led_ctrl->pwm_dev) {
-		rc = pwm_config(ir_led_ctrl->pwm_dev,
-			ir_led_data->pwm_duty_on_ns,
-			ir_led_data->pwm_period_ns);
-
-		if (rc) {
-			pr_err("PWM config failed (%d)\n", rc);
-			return rc;
-		}
-		/*workaround to disable pwm_module*/
-		udelay(50);
+	CDBG("Enter\n");
 
+	if (ir_led_ctrl->pwm_dev)
 		pwm_disable(ir_led_ctrl->pwm_dev);
-	} else {
-		CDBG("pwm device is null\n");
-	}
+	else
+		pr_err("pwm device is null\n");
 
+	CDBG("Exit\n");
 	return 0;
 }
 
@@ -128,7 +110,7 @@ static int32_t msm_ir_led_on(
 	struct msm_ir_led_ctrl_t *ir_led_ctrl,
 	struct msm_ir_led_cfg_data_t *ir_led_data)
 {
-	int32_t rc = 0;
+	int rc;
 
 	CDBG("pwm duty on(ns) %d, pwm period(ns) %d\n",
 		ir_led_data->pwm_duty_on_ns, ir_led_data->pwm_period_ns);
@@ -147,9 +129,9 @@ static int32_t msm_ir_led_on(
 			pr_err("PWM enable failed(%d)\n", rc);
 			return rc;
 		}
-	} else {
-		CDBG("pwm device is null\n");
-	}
+	} else
+		pr_err("pwm device is null\n");
+
 	return 0;
 }
 
@@ -162,10 +144,12 @@ static int32_t msm_ir_led_handle_init(
 	enum msm_ir_led_driver_type ir_led_driver_type =
 		ir_led_ctrl->ir_led_driver_type;
 
+	CDBG("Enter\n");
+
 	if (ir_led_ctrl->ir_led_state == MSM_CAMERA_IR_LED_INIT) {
 		pr_err("Invalid ir_led state = %d\n",
 				ir_led_ctrl->ir_led_state);
-		return rc;
+		return 0;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(ir_led_table); i++) {
@@ -191,8 +175,8 @@ static int32_t msm_ir_led_handle_init(
 
 	ir_led_ctrl->ir_led_state = MSM_CAMERA_IR_LED_INIT;
 
-	CDBG("IR LED STATE intialised Successfully\n");
-	return rc;
+	CDBG("Exit\n");
+	return 0;
 }
 
 static int32_t msm_ir_led_config(struct msm_ir_led_ctrl_t *ir_led_ctrl,
@@ -202,10 +186,10 @@ static int32_t msm_ir_led_config(struct msm_ir_led_ctrl_t *ir_led_ctrl,
 	struct msm_ir_led_cfg_data_t *ir_led_data =
 		(struct msm_ir_led_cfg_data_t *) argp;
 
-	CDBG("type %d\n", ir_led_data->cfg_type);
-
 	mutex_lock(ir_led_ctrl->ir_led_mutex);
 
+	CDBG("type %d\n", ir_led_data->cfg_type);
+
 	switch (ir_led_data->cfg_type) {
 	case CFG_IR_LED_INIT:
 		rc = msm_ir_led_handle_init(ir_led_ctrl, ir_led_data);
@@ -213,7 +197,7 @@ static int32_t msm_ir_led_config(struct msm_ir_led_ctrl_t *ir_led_ctrl,
 	case CFG_IR_LED_RELEASE:
 		if (ir_led_ctrl->ir_led_state == MSM_CAMERA_IR_LED_INIT)
 			rc = ir_led_ctrl->func_tbl->camera_ir_led_release(
-				ir_led_ctrl, ir_led_data);
+				ir_led_ctrl);
 		break;
 	case CFG_IR_LED_OFF:
 		if (ir_led_ctrl->ir_led_state == MSM_CAMERA_IR_LED_INIT)
@@ -232,7 +216,7 @@ static int32_t msm_ir_led_config(struct msm_ir_led_ctrl_t *ir_led_ctrl,
 
 	mutex_unlock(ir_led_ctrl->ir_led_mutex);
 
-	CDBG("Exit (%d): type %d\n", rc, ir_led_data->cfg_type);
+	CDBG("Exit: type %d\n", ir_led_data->cfg_type);
 
 	return rc;
 }
@@ -242,7 +226,8 @@ static long msm_ir_led_subdev_ioctl(struct v4l2_subdev *sd,
 {
 	struct msm_ir_led_ctrl_t *fctrl = NULL;
 	void __user *argp = (void __user *)arg;
-	struct msm_ir_led_cfg_data_t ir_led_data = {0};
+
+	CDBG("Enter\n");
 
 	if (!sd) {
 		pr_err(" v4l2 ir led subdevice is NULL\n");
@@ -265,13 +250,13 @@ static long msm_ir_led_subdev_ioctl(struct v4l2_subdev *sd,
 			pr_err("No call back funcions\n");
 			return -EINVAL;
 		} else {
-			return fctrl->func_tbl->camera_ir_led_release(fctrl,
-							&ir_led_data);
+			return fctrl->func_tbl->camera_ir_led_release(fctrl);
 		}
 	default:
 		pr_err_ratelimited("invalid cmd %d\n", cmd);
 		return -ENOIOCTLCMD;
 	}
+	CDBG("Exit\n");
 }
 
 static struct v4l2_subdev_core_ops msm_ir_led_subdev_core_ops = {
@@ -282,13 +267,39 @@ static struct v4l2_subdev_ops msm_ir_led_subdev_ops = {
 	.core = &msm_ir_led_subdev_core_ops,
 };
 
-static const struct v4l2_subdev_internal_ops msm_ir_led_internal_ops;
+static int msm_ir_led_close(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh) {
+
+	int rc = 0;
+	struct msm_ir_led_ctrl_t *ir_led_ctrl = v4l2_get_subdevdata(sd);
+
+	if (!ir_led_ctrl) {
+		pr_err("v4l2 subdevice data read failed\n");
+		return -EINVAL;
+	}
+
+	CDBG("Enter\n");
+
+	if (ir_led_ctrl->ir_led_state == MSM_CAMERA_IR_LED_INIT)
+		rc = ir_led_ctrl->func_tbl->camera_ir_led_release(
+			ir_led_ctrl);
+
+	CDBG("Exit (%d)\n", rc);
+
+	return rc;
+}
+
+static const struct v4l2_subdev_internal_ops msm_ir_led_internal_ops = {
+	.close = msm_ir_led_close,
+};
 
 static int32_t msm_ir_led_get_dt_data(struct device_node *of_node,
 	struct msm_ir_led_ctrl_t *fctrl)
 {
 	int32_t rc = 0;
 
+	CDBG("called\n");
+
 	/* Read the sub device */
 	rc = of_property_read_u32(of_node, "cell-index", &fctrl->pdev->id);
 	if (rc < 0) {
@@ -312,6 +323,7 @@ static long msm_ir_led_subdev_do_ioctl(
 		(struct msm_ir_led_cfg_data_t32 *)arg;
 	struct msm_ir_led_cfg_data_t ir_led_data;
 
+	CDBG("Enter\n");
 	ir_led_data.cfg_type = u32->cfg_type;
 	ir_led_data.pwm_duty_on_ns = u32->pwm_duty_on_ns;
 	ir_led_data.pwm_period_ns = u32->pwm_period_ns;
@@ -326,6 +338,7 @@ static long msm_ir_led_subdev_do_ioctl(
 
 	rc = msm_ir_led_subdev_ioctl(sd, cmd, &ir_led_data);
 
+	CDBG("Exit\n");
 	return rc;
 }
 
@@ -341,6 +354,7 @@ static int32_t msm_ir_led_platform_probe(struct platform_device *pdev)
 	int32_t rc = 0;
 	struct msm_ir_led_ctrl_t *ir_led_ctrl = NULL;
 
+	CDBG("Enter\n");
 	if (!pdev->dev.of_node) {
 		pr_err("IR LED device node is not present in device tree\n");
 		return -EINVAL;
@@ -356,20 +370,16 @@ static int32_t msm_ir_led_platform_probe(struct platform_device *pdev)
 	/* Reading PWM device node */
 	ir_led_ctrl->pwm_dev = of_pwm_get(pdev->dev.of_node, NULL);
 
-	if (PTR_ERR(ir_led_ctrl->pwm_dev) == -EPROBE_DEFER) {
-		pr_info("Deferring probe...Cannot get PWM device\n");
-		return -EPROBE_DEFER;
-	}
-
 	if (IS_ERR(ir_led_ctrl->pwm_dev)) {
 		rc = PTR_ERR(ir_led_ctrl->pwm_dev);
-		CDBG("Cannot get PWM device (%d)\n", rc);
+		pr_err("Cannot get PWM device (%d)\n", rc);
 		ir_led_ctrl->pwm_dev = NULL;
 	}
 
 	rc = msm_ir_led_get_dt_data(pdev->dev.of_node, ir_led_ctrl);
 	if (rc < 0) {
 		pr_err("msm_ir_led_get_dt_data failed\n");
+		devm_kfree(&pdev->dev, ir_led_ctrl);
 		return -EINVAL;
 	}
 
@@ -391,12 +401,7 @@ static int32_t msm_ir_led_platform_probe(struct platform_device *pdev)
 	ir_led_ctrl->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
 	ir_led_ctrl->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_IR_LED;
 	ir_led_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x1;
-
-	rc = msm_sd_register(&ir_led_ctrl->msm_sd);
-	if (rc < 0) {
-		pr_err("sub dev register failed for ir_led device\n");
-		return rc;
-	}
+	msm_sd_register(&ir_led_ctrl->msm_sd);
 
 	CDBG("ir_led sd name = %s\n",
 		ir_led_ctrl->msm_sd.sd.entity.name);
@@ -426,6 +431,7 @@ static int __init msm_ir_led_init_module(void)
 {
 	int32_t rc = 0;
 
+	CDBG("Enter\n");
 	rc = platform_driver_register(&msm_ir_led_platform_driver);
 	if (!rc)
 		return rc;
