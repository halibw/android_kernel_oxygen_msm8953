--- drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
+++ drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -47,37 +47,19 @@
 
 #define ISPIF_TIMEOUT_SLEEP_US                1000
 #define ISPIF_TIMEOUT_ALL_US               1000000
-#define ISPIF_SOF_DEBUG_COUNT                   0
-
-/* 3D Threshold value according guidelines for line width 1280 */
-#define STEREO_DEFAULT_3D_THRESHOLD           0x36
-
-/*
- * Overflows before restarting interface during stereo usecase
- * to give some tolerance for cases when the two sensors sync fails
- * this value is chosen by experiment
- */
-#define MAX_PIX_OVERFLOW_ERROR_COUNT 10
-static int pix_overflow_error_count[VFE_MAX] = { 0 };
+#define ISPIF_SOF_DEBUG_COUNT                    0
 
 #undef CDBG
 #ifdef CONFIG_MSMB_CAMERA_DEBUG
 #define CDBG(fmt, args...) pr_debug(fmt, ##args)
 #else
-#define CDBG(fmt, args...)
+#define CDBG(fmt, args...) do { } while (0)
 #endif
 
-/* Backward interface compatibility for 3D THRESHOLD calculation */
-#define ISPIF_USE_DEFAULT_THRESHOLD (0)
-#define ISPIF_CALCULATE_THRESHOLD (1)
-
 static int msm_ispif_clk_ahb_enable(struct ispif_device *ispif, int enable);
 static int ispif_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
 static long msm_ispif_subdev_ioctl_unlocked(struct v4l2_subdev *sd,
 	unsigned int cmd, void *arg);
-static long msm_ispif_dispatch_cmd(enum ispif_cfg_type_t cmd,
-				struct ispif_device *ispif,
-				struct msm_ispif_param_data_ext *params);
 
 int msm_ispif_get_clk_info(struct ispif_device *ispif_dev,
 	struct platform_device *pdev);
@@ -272,7 +254,16 @@ static long msm_ispif_cmd_ext(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&ispif->mutex);
-	rc = msm_ispif_dispatch_cmd(pcdata.cfg_type, ispif, params);
+	switch (pcdata.cfg_type) {
+	case ISPIF_CFG2:
+		rc = msm_ispif_config2(ispif, params);
+		msm_ispif_io_dump_reg(ispif);
+		break;
+	default:
+		pr_err("%s: invalid cfg_type\n", __func__);
+		rc = -EINVAL;
+		break;
+	}
 	mutex_unlock(&ispif->mutex);
 	kfree(params);
 	return rc;
@@ -459,7 +450,7 @@ static int msm_ispif_reset_hw(struct ispif_device *ispif)
 		/* This is set when device is 8974 */
 		ispif->clk_idx = 1;
 	}
-	memset(ispif->stereo_configured, 0, sizeof(ispif->stereo_configured));
+
 	atomic_set(&ispif->reset_trig[VFE0], 1);
 	/* initiate reset of ISPIF */
 	msm_camera_io_w(ISPIF_RST_CMD_MASK,
@@ -867,33 +858,15 @@ static uint16_t msm_ispif_get_cids_mask_from_cfg(
 
 	return cids_mask;
 }
-
-static uint16_t msm_ispif_get_right_cids_mask_from_cfg(
-	struct msm_ispif_right_param_entry *entry, int num_cids)
-{
-	int i;
-	uint16_t cids_mask = 0;
-
-	BUG_ON(!entry);
-
-	for (i = 0; i < num_cids && i < MAX_CID_CH_v2; i++) {
-		if (entry->cids[i] < CID_MAX)
-			cids_mask |= (1 << entry->cids[i]);
-	}
-
-	return cids_mask;
-}
-
 static int msm_ispif_config(struct ispif_device *ispif,
 	void *data)
 {
 	int rc = 0, i = 0;
-	uint16_t cid_mask = 0;
-	uint16_t cid_right_mask = 0;
+	uint16_t cid_mask;
 	enum msm_ispif_intftype intftype;
 	enum msm_ispif_vfe_intf vfe_intf;
-	struct msm_ispif_param_data_ext *params =
-		(struct msm_ispif_param_data_ext *)data;
+	struct msm_ispif_param_data *params =
+		(struct msm_ispif_param_data *)data;
 
 	BUG_ON(!ispif);
 	BUG_ON(!params);
@@ -943,15 +916,9 @@ static int msm_ispif_config(struct ispif_device *ispif,
 			return -EINVAL;
 		}
 
-		if (ispif->csid_version >= CSID_VERSION_V30) {
+		if (ispif->csid_version >= CSID_VERSION_V30)
 			msm_ispif_select_clk_mux(ispif, intftype,
 				params->entries[i].csid, vfe_intf);
-			if (intftype == PIX0 && params->stereo_enable &&
-			    params->right_entries[i].csid < CSID_MAX)
-				msm_ispif_select_clk_mux(ispif, PIX1,
-					params->right_entries[i].csid,
-					vfe_intf);
-		}
 
 		rc = msm_ispif_validate_intf_status(ispif, intftype, vfe_intf);
 		if (rc) {
@@ -962,26 +929,10 @@ static int msm_ispif_config(struct ispif_device *ispif,
 
 		msm_ispif_sel_csid_core(ispif, intftype,
 			params->entries[i].csid, vfe_intf);
-		if (intftype == PIX0 && params->stereo_enable &&
-		    params->right_entries[i].csid < CSID_MAX)
-			/* configure right stereo csid */
-			msm_ispif_sel_csid_core(ispif, PIX1,
-				params->right_entries[i].csid, vfe_intf);
-
 		cid_mask = msm_ispif_get_cids_mask_from_cfg(
 				&params->entries[i]);
 		msm_ispif_enable_intf_cids(ispif, intftype,
 			cid_mask, vfe_intf, 1);
-		if (params->stereo_enable)
-			cid_right_mask = msm_ispif_get_right_cids_mask_from_cfg(
-					&params->right_entries[i],
-					params->entries[i].num_cids);
-		else
-			cid_right_mask = 0;
-		if (cid_right_mask && params->stereo_enable)
-			/* configure right stereo cids */
-			msm_ispif_enable_intf_cids(ispif, PIX1,
-				cid_right_mask, vfe_intf, 1);
 		if (params->entries[i].crop_enable)
 			msm_ispif_enable_crop(ispif, intftype, vfe_intf,
 				params->entries[i].crop_start_pixel,
@@ -1014,44 +965,8 @@ static int msm_ispif_config(struct ispif_device *ispif,
 	return rc;
 }
 
-static void msm_ispif_config_stereo(struct ispif_device *ispif,
-	struct msm_ispif_param_data_ext *params, int use_line_width) {
-
-	int i;
-	enum msm_ispif_vfe_intf vfe_intf;
-	uint32_t stereo_3d_threshold = STEREO_DEFAULT_3D_THRESHOLD;
-
-	if (params->num > MAX_PARAM_ENTRIES)
-		return;
-
-	for (i = 0; i < params->num; i++) {
-		vfe_intf = params->entries[i].vfe_intf;
-		if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
-			pr_err("%s: invalid interface type %d\n", __func__,
-				vfe_intf);
-			return;
-		}
-		if (params->entries[i].intftype == PIX0 &&
-			params->stereo_enable &&
-			params->right_entries[i].csid < CSID_MAX &&
-			!ispif->stereo_configured[vfe_intf]) {
-			msm_camera_io_w_mb(0x3,
-				ispif->base + ISPIF_VFE_m_OUTPUT_SEL(vfe_intf));
-			if (use_line_width &&
-				(params->line_width[vfe_intf] > 0))
-				stereo_3d_threshold =
-					(params->line_width[vfe_intf] +
-							2 * 6 - 1) / (2 * 6);
-			msm_camera_io_w_mb(stereo_3d_threshold,
-				ispif->base +
-					ISPIF_VFE_m_3D_THRESHOLD(vfe_intf));
-			ispif->stereo_configured[vfe_intf] = 1;
-		}
-	}
-}
-
 static void msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
-	struct msm_ispif_param_data_ext *params)
+	struct msm_ispif_param_data *params)
 {
 	uint8_t vc;
 	int i, k;
@@ -1096,19 +1011,6 @@ static void msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
 				ispif->applied_intf_cmd[vfe_intf].intf_cmd |=
 					(cmd_bits << (vc * 2 + intf_type * 8));
 			}
-			if (intf_type == PIX0 && params->stereo_enable &&
-			    params->right_entries[i].cids[k] < CID_MAX) {
-				cid = params->right_entries[i].cids[k];
-				vc = cid / 4;
-
-				/* fill right stereo command */
-				/* zero 2 bits */
-				ispif->applied_intf_cmd[vfe_intf].intf_cmd &=
-					~(0x3 << (vc * 2 + PIX1 * 8));
-				/* set cmd bits */
-				ispif->applied_intf_cmd[vfe_intf].intf_cmd |=
-					(cmd_bits << (vc * 2 + PIX1 * 8));
-			}
 		}
 		/* cmd for PIX0, PIX1, RDI0, RDI1 */
 		if (ispif->applied_intf_cmd[vfe_intf].intf_cmd != 0xFFFFFFFF)
@@ -1125,7 +1027,7 @@ static void msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
 }
 
 static int msm_ispif_stop_immediately(struct ispif_device *ispif,
-	struct msm_ispif_param_data_ext *params)
+	struct msm_ispif_param_data *params)
 {
 	int i, rc = 0;
 	uint16_t cid_mask = 0;
@@ -1153,24 +1055,13 @@ static int msm_ispif_stop_immediately(struct ispif_device *ispif,
 			&params->entries[i]);
 		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
 			cid_mask, params->entries[i].vfe_intf, 0);
-		if (params->stereo_enable) {
-			ispif->stereo_configured[
-					params->entries[i].vfe_intf] = 0;
-			cid_mask = msm_ispif_get_right_cids_mask_from_cfg(
-					&params->right_entries[i],
-					params->entries[i].num_cids);
-			if (cid_mask)
-				msm_ispif_enable_intf_cids(ispif,
-					params->entries[i].intftype, cid_mask,
-					params->entries[i].vfe_intf, 0);
-		}
 	}
 
 	return rc;
 }
 
 static int msm_ispif_start_frame_boundary(struct ispif_device *ispif,
-	struct msm_ispif_param_data_ext *params)
+	struct msm_ispif_param_data *params)
 {
 	int rc = 0;
 
@@ -1186,15 +1077,13 @@ static int msm_ispif_start_frame_boundary(struct ispif_device *ispif,
 		rc = -EINVAL;
 		return rc;
 	}
-
-	msm_ispif_config_stereo(ispif, params, ISPIF_USE_DEFAULT_THRESHOLD);
 	msm_ispif_intf_cmd(ispif, ISPIF_INTF_CMD_ENABLE_FRAME_BOUNDARY, params);
 
 	return rc;
 }
 
 static int msm_ispif_restart_frame_boundary(struct ispif_device *ispif,
-	struct msm_ispif_param_data_ext *params)
+	struct msm_ispif_param_data *params)
 {
 	int rc = 0, i;
 	long timeout = 0;
@@ -1336,11 +1225,10 @@ end:
 }
 
 static int msm_ispif_stop_frame_boundary(struct ispif_device *ispif,
-	struct msm_ispif_param_data_ext *params)
+	struct msm_ispif_param_data *params)
 {
 	int i, rc = 0;
 	uint16_t cid_mask = 0;
-	uint16_t cid_right_mask = 0;
 	uint32_t intf_addr;
 	enum msm_ispif_vfe_intf vfe_intf;
 	uint32_t stop_flag = 0;
@@ -1378,13 +1266,6 @@ static int msm_ispif_stop_frame_boundary(struct ispif_device *ispif,
 	for (i = 0; i < params->num; i++) {
 		cid_mask =
 			msm_ispif_get_cids_mask_from_cfg(&params->entries[i]);
-		if (params->stereo_enable)
-			cid_right_mask =
-				msm_ispif_get_right_cids_mask_from_cfg(
-						&params->right_entries[i],
-						params->entries[i].num_cids);
-		else
-			cid_right_mask = 0;
 		vfe_intf = params->entries[i].vfe_intf;
 
 		switch (params->entries[i].intftype) {
@@ -1416,26 +1297,10 @@ static int msm_ispif_stop_frame_boundary(struct ispif_device *ispif,
 					ISPIF_TIMEOUT_ALL_US);
 		if (rc < 0)
 			pr_err("ISPIF stop frame boundary timeout\n");
-		if (cid_right_mask) {
-			ispif->stereo_configured[
-					params->entries[i].vfe_intf] = 0;
-			intf_addr = ISPIF_VFE_m_PIX_INTF_n_STATUS(vfe_intf, 1);
-			rc = readl_poll_timeout(ispif->base + intf_addr,
-						stop_flag,
-						(stop_flag & 0xF) == 0xF,
-						ISPIF_TIMEOUT_SLEEP_US,
-						ISPIF_TIMEOUT_ALL_US);
-			if (rc < 0)
-				pr_err("ISPIF stop frame boundary timeout\n");
-		}
 
 		/* disable CIDs in CID_MASK register */
 		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
 			cid_mask, vfe_intf, 0);
-		if (cid_right_mask)
-			msm_ispif_enable_intf_cids(ispif,
-				params->entries[i].intftype, cid_right_mask,
-				params->entries[i].vfe_intf, 0);
 	}
 
 end:
@@ -1456,14 +1321,6 @@ static void ispif_process_irq(struct ispif_device *ispif,
 		ispif->sof_count[vfe_id].sof_cnt[PIX0]++;
 		ispif->ispif_sof_debug++;
 	}
-	if (out[vfe_id].ispifIrqStatus1 &
-			ISPIF_IRQ_STATUS_PIX_SOF_MASK) {
-		if (ispif->ispif_sof_debug < ISPIF_SOF_DEBUG_COUNT*2)
-			pr_err("%s: PIX1 frame id: %u\n", __func__,
-				ispif->sof_count[vfe_id].sof_cnt[PIX1]);
-		ispif->sof_count[vfe_id].sof_cnt[PIX1]++;
-		ispif->ispif_sof_debug++;
-	}
 	if (out[vfe_id].ispifIrqStatus0 &
 			ISPIF_IRQ_STATUS_RDI0_SOF_MASK) {
 		if (ispif->ispif_rdi0_debug < ISPIF_SOF_DEBUG_COUNT)
@@ -1490,54 +1347,12 @@ static void ispif_process_irq(struct ispif_device *ispif,
 	}
 }
 
-static int msm_ispif_reconfig_3d_output(struct ispif_device *ispif,
-		enum msm_ispif_vfe_intf vfe_id)
-{
-	uint32_t reg_data;
-
-	BUG_ON(!ispif);
-
-	if (!((vfe_id == VFE0) ||  (vfe_id == VFE1))) {
-		pr_err("%s;%d Cannot reconfigure 3D mode for VFE%d", __func__,
-				__LINE__ , vfe_id);
-		return -EINVAL;
-	}
-	pr_info("%s;%d Reconfiguring 3D mode for VFE%d", __func__, __LINE__,
-			vfe_id);
-	reg_data =  0xFFFCFFFC;
-	msm_camera_io_w_mb(reg_data, ispif->base +
-			ISPIF_VFE_m_INTF_CMD_0(vfe_id));
-	msm_camera_io_w_mb(reg_data, ispif->base +
-			ISPIF_IRQ_GLOBAL_CLEAR_CMD_ADDR);
-
-	if (vfe_id == VFE0) {
-		reg_data = 0;
-		reg_data |= (PIX_0_VFE_RST_STB | PIX_1_VFE_RST_STB |
-				STROBED_RST_EN | PIX_0_CSID_RST_STB |
-				PIX_1_CSID_RST_STB | PIX_OUTPUT_0_MISR_RST_STB);
-		msm_camera_io_w_mb(reg_data, ispif->base + ISPIF_RST_CMD_ADDR);
-	} else {
-		reg_data = 0;
-		reg_data |= (PIX_0_VFE_RST_STB | PIX_1_VFE_RST_STB |
-				STROBED_RST_EN | PIX_0_CSID_RST_STB |
-				PIX_1_CSID_RST_STB | PIX_OUTPUT_0_MISR_RST_STB);
-		msm_camera_io_w_mb(reg_data, ispif->base +
-				ISPIF_RST_CMD_1_ADDR);
-	}
-
-	reg_data = 0xFFFDFFFD;
-	msm_camera_io_w_mb(reg_data, ispif->base +
-			ISPIF_VFE_m_INTF_CMD_0(vfe_id));
-	return 0;
-}
-
 static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
 	void *data)
 {
 	struct ispif_device *ispif = (struct ispif_device *)data;
 	bool fatal_err = false;
 	int i = 0;
-	uint32_t reg_data;
 
 	BUG_ON(!ispif);
 	BUG_ON(!out);
@@ -1588,12 +1403,6 @@ static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
 			fatal_err = true;
 		}
 
-		if (out[VFE0].ispifIrqStatus1 & PIX_INTF_1_OVERFLOW_IRQ) {
-			pr_err_ratelimited("%s: VFE0 pix1 overflow.\n",
-				__func__);
-			fatal_err = true;
-		}
-
 		if (out[VFE0].ispifIrqStatus0 & RAW_INTF_0_OVERFLOW_IRQ) {
 			pr_err_ratelimited("%s: VFE0 rdi0 overflow.\n",
 				__func__);
@@ -1626,12 +1435,6 @@ static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
 			fatal_err = true;
 		}
 
-		if (out[VFE1].ispifIrqStatus1 & PIX_INTF_1_OVERFLOW_IRQ) {
-			pr_err_ratelimited("%s: VFE1 pix1 overflow.\n",
-				__func__);
-			fatal_err = true;
-		}
-
 		if (out[VFE1].ispifIrqStatus0 & RAW_INTF_0_OVERFLOW_IRQ) {
 			pr_err_ratelimited("%s: VFE1 rdi0 overflow.\n",
 				__func__);
@@ -1653,43 +1456,6 @@ static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
 		ispif_process_irq(ispif, out, VFE1);
 	}
 
-	if ((out[VFE0].ispifIrqStatus0 &  PIX_INTF_0_OVERFLOW_IRQ) ||
-	    (out[VFE0].ispifIrqStatus1 &  PIX_INTF_0_OVERFLOW_IRQ) ||
-	    (out[VFE0].ispifIrqStatus2 &  (L_R_SOF_MISMATCH_ERR_IRQ |
-		L_R_EOF_MISMATCH_ERR_IRQ | L_R_SOL_MISMATCH_ERR_IRQ))) {
-		reg_data = msm_camera_io_r(ispif->base +
-				ISPIF_VFE_m_OUTPUT_SEL(VFE0));
-		if ((reg_data & 0x03) == VFE_PIX_INTF_SEL_3D) {
-			pix_overflow_error_count[VFE0]++;
-			if (pix_overflow_error_count[VFE0] >=
-					MAX_PIX_OVERFLOW_ERROR_COUNT) {
-				msm_ispif_reconfig_3d_output(ispif, VFE0);
-				pix_overflow_error_count[VFE0] = 0;
-			}
-			fatal_err = false;
-		}
-	}
-
-	if (ispif->vfe_info.num_vfe > 1) {
-		if ((out[VFE1].ispifIrqStatus0 &  PIX_INTF_0_OVERFLOW_IRQ) ||
-		   (out[VFE1].ispifIrqStatus1 &  PIX_INTF_0_OVERFLOW_IRQ) ||
-		   (out[VFE1].ispifIrqStatus2 &  (L_R_SOF_MISMATCH_ERR_IRQ |
-		    L_R_EOF_MISMATCH_ERR_IRQ | L_R_SOL_MISMATCH_ERR_IRQ))) {
-			reg_data = msm_camera_io_r(ispif->base +
-					ISPIF_VFE_m_OUTPUT_SEL(VFE1));
-			if ((reg_data & 0x03) == VFE_PIX_INTF_SEL_3D) {
-				pix_overflow_error_count[VFE1]++;
-				if (pix_overflow_error_count[VFE1] >=
-						MAX_PIX_OVERFLOW_ERROR_COUNT) {
-					msm_ispif_reconfig_3d_output(ispif,
-									VFE1);
-					pix_overflow_error_count[VFE1] = 0;
-				}
-			}
-			fatal_err = false;
-		}
-	}
-
 	if (fatal_err == true) {
 		pr_err_ratelimited("%s: fatal error, stop ispif immediately\n",
 			__func__);
@@ -1745,11 +1511,6 @@ static int msm_ispif_init(struct ispif_device *ispif,
 		return rc;
 	}
 
-	rc = msm_camera_enable_irq(ispif->irq, 1);
-	if (rc < 0) {
-		pr_err("%s: Error enabling IRQs\n", __func__);
-		return rc;
-	}
 	/* can we set to zero? */
 	ispif->applied_intf_cmd[VFE0].intf_cmd  = 0xFFFFFFFF;
 	ispif->applied_intf_cmd[VFE0].intf_cmd1 = 0xFFFFFFFF;
@@ -1806,100 +1567,61 @@ static void msm_ispif_release(struct ispif_device *ispif)
 		pr_err("%s: failed to remove vote for AHB\n", __func__);
 }
 
-static long msm_ispif_dispatch_cmd(enum ispif_cfg_type_t cmd,
-				struct ispif_device *ispif,
-				struct msm_ispif_param_data_ext *params)
+static long msm_ispif_cmd(struct v4l2_subdev *sd, void *arg)
 {
 	long rc = 0;
+	struct ispif_cfg_data *pcdata = (struct ispif_cfg_data *)arg;
+	struct ispif_device *ispif =
+		(struct ispif_device *)v4l2_get_subdevdata(sd);
 
-	switch (cmd) {
+	BUG_ON(!sd);
+	BUG_ON(!pcdata);
+
+	mutex_lock(&ispif->mutex);
+	switch (pcdata->cfg_type) {
+	case ISPIF_ENABLE_REG_DUMP:
+		ispif->enb_dump_reg = pcdata->reg_dump; /* save dump config */
+		break;
+	case ISPIF_INIT:
+		rc = msm_ispif_init(ispif, pcdata->csid_version);
+		msm_ispif_io_dump_reg(ispif);
+		break;
 	case ISPIF_CFG:
-		rc = msm_ispif_config(ispif, params);
+		rc = msm_ispif_config(ispif, &pcdata->params);
 		msm_ispif_io_dump_reg(ispif);
 		break;
 	case ISPIF_START_FRAME_BOUNDARY:
-		rc = msm_ispif_start_frame_boundary(ispif, params);
+		rc = msm_ispif_start_frame_boundary(ispif, &pcdata->params);
 		msm_ispif_io_dump_reg(ispif);
 		break;
 	case ISPIF_RESTART_FRAME_BOUNDARY:
-		rc = msm_ispif_restart_frame_boundary(ispif, params);
+		rc = msm_ispif_restart_frame_boundary(ispif, &pcdata->params);
 		msm_ispif_io_dump_reg(ispif);
 		break;
+
 	case ISPIF_STOP_FRAME_BOUNDARY:
-		rc = msm_ispif_stop_frame_boundary(ispif, params);
+		rc = msm_ispif_stop_frame_boundary(ispif, &pcdata->params);
 		msm_ispif_io_dump_reg(ispif);
 		break;
 	case ISPIF_STOP_IMMEDIATELY:
-		rc = msm_ispif_stop_immediately(ispif, params);
+		rc = msm_ispif_stop_immediately(ispif, &pcdata->params);
 		msm_ispif_io_dump_reg(ispif);
 		break;
 	case ISPIF_RELEASE:
 		msm_ispif_reset(ispif);
 		msm_ispif_reset_hw(ispif);
 		break;
-	case ISPIF_CFG2:
-		rc = msm_ispif_config2(ispif, params);
-		msm_ispif_io_dump_reg(ispif);
-		break;
-	case ISPIF_CFG_STEREO:
-		msm_ispif_config_stereo(ispif, params,
-						ISPIF_CALCULATE_THRESHOLD);
-		break;
-	default:
-		pr_err("%s: invalid cfg_type\n", __func__);
-		rc = -EINVAL;
-		break;
-	}
-	return rc;
-}
-
-static long msm_ispif_cmd(struct v4l2_subdev *sd, void *arg)
-{
-	long rc = 0;
-	struct ispif_cfg_data *pcdata = (struct ispif_cfg_data *)arg;
-	struct ispif_device *ispif =
-		(struct ispif_device *)v4l2_get_subdevdata(sd);
-	int i;
-	struct msm_ispif_param_data_ext params;
-
-	BUG_ON(!sd);
-	BUG_ON(!pcdata);
-	mutex_lock(&ispif->mutex);
-	switch (pcdata->cfg_type) {
-	case ISPIF_ENABLE_REG_DUMP:
-		/* save dump config */
-		ispif->enb_dump_reg = pcdata->reg_dump;
-		break;
-	case ISPIF_INIT:
-		rc = msm_ispif_init(ispif, pcdata->csid_version);
-		msm_ispif_io_dump_reg(ispif);
-		break;
 	case ISPIF_SET_VFE_INFO:
 		rc = msm_ispif_set_vfe_info(ispif, &pcdata->vfe_info);
 		break;
 	default:
-		memset(&params, 0, sizeof(params));
-		if (pcdata->params.num > MAX_PARAM_ENTRIES) {
-			pr_err("%s: invalid num entries %u\n", __func__,
-					 pcdata->params.num);
-			rc = -EINVAL;
-		} else {
-			params.num = pcdata->params.num;
-			for (i = 0; i < pcdata->params.num; i++)
-				memcpy(&params.entries[i],
-					&pcdata->params.entries[i],
-					sizeof(struct msm_ispif_params_entry));
-			params.stereo_enable = 0;
-			rc = msm_ispif_dispatch_cmd(pcdata->cfg_type, ispif,
-							&params);
-		}
+		pr_err("%s: invalid cfg_type\n", __func__);
+		rc = -EINVAL;
 		break;
 	}
 	mutex_unlock(&ispif->mutex);
-
 	return rc;
 }
-
 static struct v4l2_file_operations msm_ispif_v4l2_subdev_fops;
 
 static long msm_ispif_subdev_ioctl_unlocked(struct v4l2_subdev *sd,
@@ -1961,6 +1683,9 @@ static int ispif_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		rc = msm_ispif_clk_ahb_enable(ispif, 1);
 		if (rc)
 			goto ahb_clk_enable_fail;
+		rc = msm_camera_enable_irq(ispif->irq, 1);
+		if (rc)
+			goto irq_enable_fail;
 	}
 	/* mem remap is done in init when the clock is on */
 	ispif->open_cnt++;
@@ -1968,6 +1693,8 @@ static int ispif_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 	return rc;
 ahb_clk_enable_fail:
 	msm_ispif_set_regulators(ispif->ispif_vdd, ispif->ispif_vdd_count, 0);
+irq_enable_fail:
+	msm_ispif_clk_ahb_enable(ispif, 0);
 unlock:
 	mutex_unlock(&ispif->mutex);
 	return rc;
